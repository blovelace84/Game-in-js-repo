import { TEMPLATES, Sound } from 'pfxr';

/**
 * Shader uniform values (scalars, vec2, vec3, vec4)
 */
type Uniforms = Record<string, number | [number, number] | [number, number, number] | [number, number, number, number]>;
declare const filters: {
    fractal: {
        fragment: string;
        settings: {
            sideCount: number;
            scale: number;
            rotation: number;
        };
    };
    crt: {
        fragment: string;
        settings: {
            warp: number;
            lineIntensity: number;
            lineWidth: number;
            lineCount: number;
        };
    };
    neon: {
        fragment: string;
        settings: {
            scale: number;
            intensity: number;
        };
    };
    glow: {
        fragment: string;
        settings: {
            intensity: number;
        };
    };
};
type FilterKey = keyof typeof filters;
type FilterSettingsOf<T extends FilterKey> = {
    name: T;
    settings?: Partial<(typeof filters)[T]['settings']>;
};
type CustomFilterSettings = {
    fragment?: string;
    vertex?: string;
    settings?: Uniforms;
};
/**
 * Visual filter configuration - supports built-in filters or custom shaders.
 *
 * Built-in filters:
 * - 'fractal': Creates a polygon of n sides for each pixel with configurable rotation and scale
 * - 'crt': Simulates old CRT monitor with scanlines and screen curvature
 * - 'neon': Adds glowing neon-like effect with bloom
 * - 'glow': Adds a glowing effect without mosaic
 *
 * @example
 * ```typescript
 * // Built-in filter
 * const fractalFilter = {
 *   name: 'fractal',
 *   settings: {
 *     sideCount: 6, // Hexagon
 *     scale: 0.8,
 *     rotation: 45
 *   }
 * }
 *
 * // Custom shader filter
 * const customFilter = {
 *   fragment: `
 *     precision mediump float;
 *     uniform sampler2D u_texture;
 *     varying vec2 v_texcoord;
 *     void main() {
 *       gl_FragColor = texture2D(u_texture, v_texcoord) * 0.8;
 *     }
 *   `,
 *   settings: { customParam: 1.0 }
 * }
 * ```
 */
type FilterParams = {
    [K in FilterKey]: FilterSettingsOf<K>;
}[FilterKey] | CustomFilterSettings;

/**
 * Sound player configuration parameters
 */
type SoundPlayerParams = {
    /** Master volume level from 0.0 (silent) to 1.0 (full volume) */
    volume: number;
};
type SoundTemplateKey = keyof typeof TEMPLATES;
type PlaySoundArgs = [key: SoundTemplateKey] | [key: SoundTemplateKey, seed: number] | [url: `${'http' | 'https'}://${string}.${string}`] | [sound: Partial<Sound>];
type CreateSoundArgs = [key: SoundTemplateKey] | [key: SoundTemplateKey, seed: number] | [url: `${'http' | 'https'}://${string}.${string}`];
/**
 * @deprecated
 */
declare const createSound: (...args: CreateSoundArgs) => Partial<Sound>;

type Input = 'LEFT' | 'UP' | 'RIGHT' | 'DOWN' | 'ACTION';
/**
 * Input handler configuration parameters
 */
type InputsHandlerParams = {
    /** Key bindings for each input action - maps input types to keyboard event codes */
    controls: Record<Input, string | string[]>;
};

/**
 * Player configuration parameters
 * @example
 * ```typescript
 * const playerConfig = {
 *   sprite: 0, // Use color index 0
 *   position: [2, 3], // Start at coordinates x=2, y=3
 *   visible: true,
 *   onInput: (input) => {
 *     if (input === 'ACTION') console.log('Player pressed action!');
 *   },
 *   onTurn: (player) => {
 *     // Custom logic executed each turn
 *   }
 * }
 * ```
 */
type PlayerParams = {
    /** Player sprite - can be a color index (0-9), single character, or multi-line pixel art string */
    sprite?: Tile;
    /** Starting position as [x, y] coordinates on the game grid */
    position?: Position;
    /** Callback executed at the end of each turn, receives player facade */
    onTurn?: (player: Player['facade']) => any;
    /** Callback executed when player receives input, receives the input type */
    onInput?: (input: Input) => any;
    /** Whether the player sprite is visible on screen (default: true) */
    visible?: boolean;
};
declare class Player {
    #private;
    constructor(params: PlayerParams);
    subscribe(callback: () => void): () => boolean;
    saveCurrentState(): void;
    restoreSavedState(): void;
    dispatchOnTurn(): void;
    dispatchOnInput(input: Input): void;
    get visible(): boolean;
    set visible(value: boolean);
    get sprite(): Tile | null;
    get position(): Position;
    set sprite(value: Tile | null);
    set position(value: Position);
    get direction(): Position;
    setDirection(input: Input): void;
    get facade(): {
        sprite: Tile | null;
        position: Position;
        readonly direction: Position;
        visible: boolean;
    };
}

type Templates<T extends string = string> = {
    [K in T]: ((position: Position) => Template<K>) | Template<K>;
};
type Template<T extends string = string> = Partial<Omit<CellState<T>, 'id' | 'position' | 'symbol' | 'isOnScreen'>>;
type GameStateParams<T extends string = string> = {
    player: PlayerParams;
    templates: Templates<T>;
    map: string;
    filter?: FilterParams;
};
type CellState<T extends string> = {
    /** Unique identifier for this cell instance */
    id: string;
    /** The symbol/type of this cell from the template system */
    symbol: T;
    /** Visual representation - color index, character, or pixel art string */
    sprite: Tile | null;
    /** Sound effect to play on interaction */
    sound: UnTuplify<PlaySoundArgs> | null;
    /** Text displayed when player interacts with this cell */
    dialog: string | null;
    /** Whether this cell blocks movement */
    solid: boolean;
    /** Whether this cell's sprite is rendered */
    visible: boolean;
    /** Whether this cell's sprite is rendered */
    isOnScreen: boolean;
    /** Whether this cell renders in front of the player */
    foreground: boolean;
    /** Game ending condition - true ends game, string/array shows ending message */
    end: boolean | string | string[] | null;
    /** Cell position */
    position: [number, number];
    /** Called when player tries to move into this cell's position */
    onCollide?: (target: CellFacade<T>) => any;
    /** Called after player collides with this cell */
    onCollideStart?: (target: CellFacade<T>) => any;
    /** Call when a player begins to enter a cell, before dialog and sounds */
    onEnterStart?: (target: CellFacade<T>) => any;
    /** Called when player moves into this cell's position */
    onEnter?: (target: CellFacade<T>) => any;
    /** Called when player leaves this cell's position */
    onLeave?: (target: CellFacade<T>) => any;
    /** Called when this cell becomes visible on screen */
    onScreenEnter?: (target: CellFacade<T>) => any;
    /** Called when this cell goes off screen */
    onScreenLeave?: (target: CellFacade<T>) => any;
    /** Called at the end of each game turn */
    onTurn?: (target: CellFacade<T>) => any;
    /** Called when a message is sent to this cell via sendMessageToCells */
    onMessage?: (target: CellFacade<T>, message?: any) => any;
};
/**
 * Parameters for updating cell properties.
 * Excludes immutable fields (symbol, position) and event handlers to prevent accidental overwrites.
 */
type CellParams = Partial<Omit<CellState<string>, 'id' | 'symbol' | 'position' | 'onCollide' | 'onCollideStart' | 'onEnterStart' | 'onEnter' | 'onLeave' | 'onScreenEnter' | 'onScreenLeave' | 'onTurn' | 'onMessage'>>;
/**
 * Query parameters for filtering cells.
 * Supports all updateable properties plus coordinate-based and symbol-based filtering.
 *
 * @template T - String literal type for cell symbols
 */
type CellQuery<T extends string> = Partial<CellParams & {
    x?: number;
    y?: number;
    symbol?: T | T[];
}>;

/**
 * Renderer configuration parameters
 */
type RendererParams = {
    /** Width of each cell/sprite in pixels */
    cellWidth: number;
    /** Height of each cell/sprite in pixels */
    cellHeight: number;
    /** Screen width measured in cells */
    screenWidth: number;
    /** Screen height measured in cells */
    screenHeight: number;
    /** Color palette array - supports up to 62 colors */
    colors: string[];
    /** Background color (color index or CSS color) */
    background?: string | number;
};

/**
 * Camera configuration parameters
 */
type CameraParams = {
    /** Camera width constraint */
    cameraWidth?: number;
    /** Camera height constraint */
    cameraHeight?: number;
    screenWidth: RendererParams['screenWidth'];
    screenHeight: RendererParams['screenHeight'];
    map: GameStateParams<string>['map'];
};
declare class Camera {
    #private;
    position: Position;
    constructor(params: CameraParams);
    update(target: Position, mapDimensions: Position): void;
    isOnScreen(position: Position): boolean;
    reset(): void;
}

declare class GameMap {
    #private;
    constructor(map: string);
    subscribe(callback: (map: string) => void): () => boolean;
    get map(): string;
    set map(value: string);
    get dimensions(): Position;
}

type CellsParams<T extends string> = {
    templates: Templates<T>;
};
declare class Cells<T extends string> {
    #private;
    constructor(params: CellsParams<T>, gameMap: GameMap);
    subscribe(callback: () => void): void;
    getCellAt(x: number, y: number): CellFacade<T>;
    clearCellAt(x: number, y: number): void;
    updateCellAt(x: number, y: number, params: CellParams): void;
    setCellAt(x: number, y: number, symbol: T): void;
    getCells(query: CellQuery<T>): CellFacade<T>[];
    updateCells(query: CellQuery<T>, params: CellParams): void;
    clearCells(query: CellQuery<T>): void;
    setCells(query: CellQuery<T>, symbol: T): void;
    sendMessageToCells(query: CellQuery<T>, message?: any): void;
    moveCell(from: Position, to: Position): void;
    getEvent(x: number, y: number, eventKey: 'onCollide' | 'onCollideStart' | 'onEnter' | 'onEnterStart' | 'onLeave' | 'onScreenLeave' | 'onScreenEnter' | 'onTurn'): (() => any) | undefined;
    get(): CellState<T>[];
    handleScreenEvents(camera: Camera): void;
    initCells(): void;
}

declare class CellFacade<T extends string = string> {
    #private;
    constructor(position: Position, cells: Cells<T>);
    get sprite(): CellState<T>["sprite"];
    set sprite(value: CellState<T>['sprite']);
    get solid(): CellState<T>["solid"];
    set solid(value: CellState<T>['solid']);
    get sound(): CellState<T>["sound"];
    set sound(value: CellState<T>['sound']);
    get position(): [number, number];
    get dialog(): CellState<T>["dialog"];
    set dialog(value: CellState<T>['dialog']);
    get visible(): CellState<T>["visible"];
    set visible(value: CellState<T>['visible']);
    get foreground(): CellState<T>["foreground"];
    set foreground(value: CellState<T>['foreground']);
    get end(): CellState<T>["end"];
    set end(value: CellState<T>['end']);
    get symbol(): T;
    get isOnScreen(): boolean;
    remove(): void;
    moveTo(x: number, y: number): void;
}

declare const DIALOG_SPEED: {
    SLOW: number;
    NORMAL: number;
    FAST: number;
};

/**
 * Dialog configuration parameters
 */
type DialogParams = {
    /** Background color for dialog box (color index or CSS color) */
    dialogBackground: string | number;
    /** Text color for dialog content (color index or CSS color) */
    dialogColor: string | number;
    /** Border color for dialog box outline (color index or CSS color) */
    dialogBorder: string | number;
    /** Dialog typing speed ('SLOW', 'NORMAL', 'FAST') */
    dialogSpeed: keyof typeof DIALOG_SPEED;
    colors: RendererParams['colors'];
};

interface MenuOption {
    [label: string]: MenuOption | null | Function;
}

type Tile = string | number;
type Position = [number, number];
type UnTuplify<T> = T extends [infer U] ? U : T;
interface GameApi<T extends string> {
    /**
     * @deprecated use getCellAt instead
     */
    getCell: (x: number, y: number) => CellFacade<T>;
    /**
     * @deprecated use setCellAt instead
     */
    addToCell: (x: number, y: number, symbol: T) => void;
    /**
     * @deprecated use updateCellAt instead
     */
    setCell: (x: number, y: number, params: CellParams) => void;
    /**
     * @deprecated use clearCellAt instead
     */
    clearCell: (x: number, y: number) => void;
    /**
     * @deprecated use getCells
     */
    getAll: (symbol: T) => CellFacade<T>[];
    /**
     * @deprecated use updateCells
     */
    setAll: (symbol: T, params: CellParams) => void;
    player: Player['facade'];
    getCellAt: (x: number, y: number) => CellFacade<T>;
    setCellAt: (x: number, y: number, symbol: T) => void;
    updateCellAt: (x: number, y: number, params: CellParams) => void;
    clearCellAt: (x: number, y: number) => void;
    getCells: (query: CellQuery<T>) => CellFacade<T>[];
    setCells: (query: CellQuery<T>, symbol: T) => void;
    updateCells: (query: CellQuery<T>, params: CellParams) => void;
    clearCells: (query: CellQuery<T>) => void;
    sendMessageToCells: (query: CellQuery<T>, message?: any) => void;
    openDialog: (text: string) => Promise<void>;
    prompt: (...options: string[]) => Promise<number>;
    openMenu: (options: MenuOption) => Promise<void>;
    openMessage: (...args: string[]) => Promise<void> | undefined;
    playSound: (...args: PlaySoundArgs) => Promise<void>;
    end: (...messages: string[]) => void;
    loadMap: (map: string, playerPosition?: Position) => void;
    updateFilter: (uniforms: Uniforms) => void;
    width: number;
    height: number;
    turn: number;
    clear: (color?: number | string) => void;
}

/**
 * Message box configuration parameters
 */
type MessageBoxParams = {
    /** Background color for message box (color index or CSS color) */
    messageBackground: string | number;
    /** Text color for message content (color index or CSS color) */
    messageColor: string | number;
    colors: RendererParams['colors'];
};

/**
 * Game configuration object for Odyc.js games.
 * All properties are optional and will use sensible defaults if not provided.
 *
 * @template T - String literal type for cell template keys used in the map
 * @example
 * ```typescript
 * const config = {
 *   player: { sprite: 0, position: [2, 3] },
 *   templates: {
 *     x: { solid: true, sprite: 4, onCollide: (target) => target.remove() }
 *   },
 *   map: `
 *     ........
 *     ..x.....
 *     ........
 *   `,
 *   colors: ['#000', '#fff', '#f00'],
 *   filter: { name: 'crt' }
 * }
 * ```
 */
type Config<T extends string> = RendererParams & InputsHandlerParams & SoundPlayerParams & CameraParams & MessageBoxParams & DialogParams & {
    filter?: FilterParams;
} & GameStateParams<T> & {
    /** Game title displayed at the start of the game */
    title?: string | string[];
};

declare const createGame: <T extends string>(userConfig?: Partial<Config<T>>) => GameApi<T>;

type Vec2Like = [Vec2] | [Position] | Position;
declare class Vec2 {
    #private;
    x: number;
    y: number;
    constructor(x: number, y: number);
    get value(): Position;
    set value(value: Position);
    get length(): number;
    get direction(): Vec2;
    add(...args: Vec2Like): Vec2;
    sub(...args: Vec2Like): Vec2;
    multiply(value: number): Vec2;
    divide(value: number): Vec2;
    distance(...args: Vec2Like): number;
    manhattanDistance(...args: Vec2Like): number;
    equals(...args: Vec2Like): boolean;
}
type Vec2Args = [Position] | Position;
declare function vec2(...args: Vec2Args): Vec2;

declare const tick: () => Promise<void>;

declare function charToSprite(char: string, color?: string | number): string;

declare function makeScreenshot(filename: string): void;

declare function startRecording(): (filename: string) => void;

declare function mergeSprites(...sprites: (string | false | null | undefined)[]): string;

declare const __BUILD_INFO__: {
    readonly gitHash: string;
    readonly version: string;
};

export { CellFacade as Cell, type Template, __BUILD_INFO__, charToSprite, createGame, createSound, makeScreenshot, mergeSprites, startRecording, tick, vec2 };
